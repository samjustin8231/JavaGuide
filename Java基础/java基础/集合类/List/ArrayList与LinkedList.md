# ArrayList与LinkedList



ArrayList和Vector使用了基于动态数组的实现，可以认为ArrayList或者Vector封装了对内部数组的操作，比如向数组

中添加，删除，插入新的元素或者数据的扩展和重定向。

       LinkedList使用了循环双向链表数据结构。与基于数组的ArrayList 相比,这是两种截然不同的实现技术，这也决

定了它们将适用于完全不同的工作场景。

        LinkedList链表由一系列表项连接而成。 一个表项总是包含3个部分:元素内容，前驱表和后驱表

 在下图展示了一个包含3个元素的LinkedList 的各个表项间的连接关系。在JDK的实现中，无论LikedList 是否
为空,链表内部都有一个header表项，它既表示链表的开始，也表示链表的结尾。表项header的后驱表项便是链表
中第一个元素, 表项header的前驱表项便是链表中最后一个元素。

ArrayList和LinkedList在性能上各有优缺点，都有各自所适用的地方，总的说来可以描述如下： 

1. 对ArrayList和LinkedList而言，在列表末尾增加一个元素所花的开销都是固定的。对ArrayList而言，主要是在内部数组中增加一项，指向所添加的元素，偶尔可能会导致对数组重新进行分配；而对LinkedList而言，这个开销是统一的，分配一个内部Entry对象。
2. 在ArrayList的中间插入或删除一个元素意味着这个列表中剩余的元素都会被移动；而在LinkedList的中间插入或删除一个元素的开销是固定的。
3. LinkedList不支持高效的随机元素访问。
ArrayList的空间浪费主要体现在在list列表的结尾预留一定的容量空间，而LinkedList的空间花费则体现在它的每一个元素都需要消耗相当的空间

可以这样说：当操作是在一列数据的后面添加数据而不是在前面或中间,并且需要随机地访问其中的元素时,使用ArrayList会提供比较好的性能；当你的操作是在一列数据的前面或中间添加或删除数据,并且按照顺序访问其中的元素时,就应该使用LinkedList了。