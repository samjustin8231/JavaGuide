volatile理解


# JMM

理解volatile的相关知识前，先简单的认识一下JMM（Java Memory Model）,JMM是jdk5引入的一种jvm的一种规范，本身是一种抽象的概念，并不真实存在，它屏蔽了各种硬件和操作系统的访问差异，它的目的是为了解决由于多线程通过共享数据进行通信时，存在的本地内存数据不一致、编译器会对代码进行指令重排等问题。


JMM有关同步的规定：

* 线程解锁前，必须把共享变量的值刷新回主内存；
* 线程加锁前，必须读取主内存的最新值到自己的工作内存中；
* 加锁和解锁使用的是同一把锁；

**说明：**当我们在程序中new一个user对象的时候，这个对象就存在我们的主内存中，当多个线程操作主内存的name变量的时候，会先将user对象中的name属性进行拷贝一份到自己线程的工作内存中，自己修改自己工作内存中的属性后，再将修改后的属性值刷新回主内存，这就会存在一些问题，例如，一个线程写完，还没有写回到主内存，另一个线程先修改后写入到主内存，就会存在数据的丢失或者脏数据。所以，JMM就存在如下规定：

* 可见性
* 原子性
* 有序性

# Volatile关键字
volatile是java虚拟机提供的一种轻量级的同步机制，比较与synchronized。我们知道的事volatile的三大特性：

* 可见性
* 不保证原子性
* 禁止指令重排

## Volatile保证可见性的原理
> 可见性

可见性就是当多个线程操作主内存的共享数据的时候，当其中一个线程修改了数据写回主内存的时候，回立刻通知其他线程，这就是线程的可见性。

> 见一个不保证可见性的例子

```
class MyDataDemo {
    int num = 0;

    public void updateNum() {
        this.num = 60;
    }
}

public class VolatileDemo {

    public static void main(String[] args) {

        MyDataDemo myData = new MyDataDemo();

        new Thread(() -> {
            try {
                TimeUnit.SECONDS.sleep(3);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            myData.updateNum();
            System.out.println("num的值：" + myData.num);
        }, "子线程").start();

        while (myData.num == 0) {}
        System.out.println("程序执行结束");
    }
}

```

这是一个简单的示例程序，存在一个两个线程，一个子线程修改主内存的共享数据num的值，main线程使用while时时检测自己是否是道主内存的num的值是否被改变，运行程序程序执行结束并不会被打印，同时，程序也不会停止。这就是线程之间的不可见问题，解决方法就是可以添加volatile关键字，修改如下：

```
volatile int num = 0;

```

### Volatile保证可见性的原理

将Java程序生成汇编代码的时候，我们可以看见，当我们对添加了volatile关键字修饰的变量时候，会多出一条Lock前缀的的指令。我们知道的是cpu不直接与主内存进行数据交换，中间存在一个高速缓存区域，通常是一级缓存、二级缓存和三级缓存，而添加了volatile关键字进行操作时候，生成的Lock前缀的汇编指令主要有以下两个作用：

将当前处理器缓存行的数据写回系统内存；
这个写回内存的操作会使得其他CPU里缓存了该内存地址的数据无效；

在多处理器下，为了保证各个处理器的缓存是一致的，就会实现缓存一致性协议，每个处理器通过嗅探在总线上传播的数据来检查自己缓存的值是不是过期了，当处理器发现自己缓存行对应的内存地址被修改，就会将当前处理器的缓存行设置成无效状态，当处理器对这个数据进行修改操作的时候，会重新从系统内存中把数据读到处理器缓存里。


## Volatile不保证原子性

**原子性：**也可以说是保持数据的完整一致性，也就是说当某一个线程操作每一个业务的时候，不能被其他线程打断，不可以被分割操作，即整体一致性，要么同时成功，要么同时失败。

比如：使用AtomicInteger来保证原子性，或使用synchronized来保证。

## Volatile的禁止指令重排序
Volatile禁止指令重排序的原理
前面说到了volatile禁止指令重排优化，从而避免在多线程环境下出现结果错乱的现象。这是因为在volatile会在指令之间插入一条内存屏障指令，通过内存屏障指令告诉CPU和编译器不管什么指令，都不进行指令重新排序。也就说说通过插入的内存屏障禁止在内存屏障前后的指令执行指令重新排序优化。
什么是内存屏障
内存屏障是一个CPU指令，他的作用有两个：

保证特定操作的执行顺序；
保证某些变量的内存可见性；

将上述代码修改为：
volatile int num = 0;

volatile boolean falg = false;
复制代码这样就保证执行init方法的时候一定是先执行num = 1;再执行falg = true;，就避免的了结果出错的现象。





# 参考文献

[死磕Java——volatile的理解](https://juejin.im/post/5cd129b3f265da03705fcc9e)