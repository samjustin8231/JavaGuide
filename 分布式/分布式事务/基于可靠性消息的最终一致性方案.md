# ~~Java 中的事务~~
搞清楚了事务之后，我们来看点眼熟的，java 中的事务是怎么玩的？ Java 中我们平时用的最多的就是在 service 层的增删改方法上添加@Transactional 注解，让 spring 去帮我们管理事务。

它底层会给我们的 service 组件生成一个对应的 proxy 动态代理，这样所有对 service 组件的方法都由它对应的 proxy 来接管，当 proxy 在调用对应业务方法比如 add()时，proxy就会基于 AOP 的思想在调用真正的业务方法前执行 setAutoCommit（false）打开事务。

然后在业务方法执行完后执行 commit 提交事务，当在执行业务方法的过程中发生异常时就会执行 rollback 来回滚事务。

当然@Transactional 注解具体的实现细节这里不再展开，这个不是本篇文章的重点，本文的 topic 是“分布式事务”，关于@Transactional 注解大家有兴趣的话，可以自己打断点debug 源码研究下，源码出真知。



![](基于可靠性消息最终一致性方案.jpg)


## ~~流程x~~

1. A 系统先发送一个 prepared 消息到 mq，如果这个 prepared 消息发送失败那么就直接取消操作别执行了，后续操作都不再执行。
2. 如果这个消息发送成功过了，那么接着执行 A 系统的本地事务，如果执行失败就告诉 mq 回滚消息，后续操作都不再执行。
3. 如果 A 系统本地事务执行成功，就告诉 mq 发送确认消息。
4. 那如果 A 系统迟迟不发送确认消息呢？ 此时 mq 会自动定时轮询所有 prepared 消息，然后调用 A 系统事先提供的接口，通过这个接口反查 A 系统的上次本地事务是否执行成功 如果成功，就发送确认消息给 mq；失败则告诉 mq 回滚消息（后续操作都不再执行）。
5. 此时 B 系统会接收到确认消息，然后执行本地的事务，如果本地事务执行成功则事务正常完成。
6. 如果系统 B 的本地事务执行失败了咋办？ 基于 mq 重试咯，mq 会自动不断重试直到成功，如果实在是不行，可以发送报警由人工来手工回滚和补偿。 这种方案的要点就是可以基于 mq 来进行不断重试，最终一定会执行成功的。 因为一般执行失败的原因是网络抖动或者数据库瞬间负载太高，都是暂时性问题。 通过这种方案，99.9%的情况都是可以保证数据最终一致性的，剩下的 0.1%出问题的时候，就人工修复数据呗。

适用场景： 这个方案的使用还是比较广，目前国内互联网公司大都是基于这种思路玩儿的。


# 基于可靠消息的最终一致性流程
* 消费者发送pre消息给MQ(状态为待确认);
* MQ持久化pre消息(pre消息不会投递给消费者);并将结果返回给生产者；
* 生产者根据MQ的pre消息返回结果决定是否执行本地操作；
    * 失败:放弃业务操作，结束
    * 成功:执行业务操作
* 生产者业务操作执行完后将执行结果发送给MQ
* MQ根据生产者业务执行结果决定是否确认消息
    * 失败:丢弃消息，结束
    * 成功:确认消息更新消息状态为待发送 
* 消费者监听并接收"待发送"状态的消息，执行业务结果
    * 失败: 重复推送给消费者(可以按时间梯度设置最大重发次数)
   * 成功: 消费者执行业务结果后，向MQ发送ACK(消息中间件删除消息)[需要使用手动确认的方式]




# 消息发送一致性保障

* 先发pre消息，然后执行本地事务；
* 将发送pre消息和生产者本地业务放在同一个本地事务中

## 消息发送一致性的正常情况
成功发送了pre消息，同时消息中间件成功保存了pre消息，同时生产者本地事务执行成功；

## 消息发送一致性的异常情况

发送pre消息阶段：
* 如果pre消息没有存储，则生产者不会执行本地操作；结果一致
* 如果pre消息存储了，但是返回给生产者时，丢失了；不一致
* 或者pre消息存储了，同时成功的返回给生产者了；但是生产者执行本地事务的时候，失败了；不一致

发送confirm消息阶段：
* MQ存储了消息，但是生产者执行本地操作失败；不一致
* MQ存储了消息，生产者执行本地操作成功；发送comfirm给MQ时失败；不一致
* MQ存储了pre消息，生产者执行了本地操作；但是Mq执行 confirm消息时失败；则不一致

### 异常情况如何处理
MQ只需要确认下生产者的本地业务操作的执行结果；决定如何confirm消息(丢弃/修改状态为待发送)

针对所有的异常情况，MQ主动调用由生产者提供查询接口，查询该pre消息对应的生产者本地操作是否执行成功(生产者业务处理结果)


# 重复消息和幂等性问题

## 实现幂等的原因
可能重复消费的情况：
消费者业务操作执行完后，MQ没有收到消息处理结果(比如：网络问题，超时，消息中间件自身出问题了，消费代码出问题)；那么MQ就会重新投递消息

消费者端接口可能被重复调用，需要保证幂等性

## 如何保证接口幂等性

* 数据库唯一约束
* redis将请求和请求结果缓存

场景举例：

* 支付订单创建：商家编号，订单编号，订单状态
* 订单更新：订单号，订单状态(状态不对直接返回)
* 会计系统记账：系统来源，请求号(这种可能没有状态)

# 基于可靠消息一致性方案实现

一般现有的MQ不支持消息发送的一致性流程(RocketMQ 4.2.6之前支持)

## 本地消息服务



# 参考

