# 消息系统分类

## Peer-to-Peer
- 一般基于Pull或者Polling接收消息
- 发送到队列中的消息被一个而且仅仅一个接收者所接收，
即使有多个接收者在同一个队列中侦听同一消息
- 即支持异步“即发即弃”的消息传送方式，也支持同步请
求/应答传送方式

## 发布/订阅
- 发布到一个主题的消息，可被多个订阅者所接收
- 发布/订阅即可基于Push消费数据，也可基于Pull或者
Polling消费数据
- 解耦能力比P2P模型更强

# 消息系统适用场景
- 解耦 各位系统之间通过消息系统这个统一的接口交换数据，无须了解彼此的存在
- 冗余 部分消息系统具有消息持久化能力，可规避消息处理前丢失的风险
- 扩展 消息系统是统一的数据接口，各系统可独立扩展
- 峰值处理能力 消息系统可顶住峰值流量，业务系统可根据处理能力从消息系统中获取并处理对应量的请求
- 可恢复性 系统中部分组件失效并不会影响整个系统，它恢复后仍然可从消息系统中获取并处理数据
- 异步通信 在不需要立即处理请求的场景下，可以将请求放入消息系统，合适的时候再处理

# 常用消息系统对比
- RabbitMQ Erlang编写，支持多协议 AMQP，XMPP，SMTP，STOMP。支持负载均衡、数据持久化。同时
支持Peer-to-Peer和发布/订阅模式
- Redis 基于Key-Value对的NoSQL数据库，同时支持MQ功能，可做轻量级队列服务使用。就入队操作而言，
Redis对短消息（小于10KB）的性能比RabbitMQ好，长消息的性能比RabbitMQ差。
- ZeroMQ 轻量级，不需要单独的消息服务器或中间件，应用程序本身扮演该角色，Peer-to-Peer。它实质上是
一个库，需要开发人员自己组合多种技术，使用复杂度高
- ActiveMQ JMS实现，Peer-to-Peer，支持持久化、XA事务
- Kafka/Jafka 高性能跨语言的分布式发布/订阅消息系统，数据持久化，全分布式，同时支持在线和离线处理
- MetaQ/RocketMQ 纯Java实现，发布/订阅消息系统，支持本地事务和XA分布式事务

# Kafka设计目标
- 高吞吐率 在廉价的商用机器上单机可支持每秒100万条消息的读写
- 消息持久化 所有消息均被持久化到磁盘，无消息丢失，支持消息重放
- 完全分布式 Producer，Broker，Consumer均支持水平扩展
- 同时适应在线流处理和离线批处理

# 简单说明什么是kafka
Apache kafka是消息中间件的一种，我发现很多人不知道消息中间件是什么，在开始学习之前，我这边就先简单的解释一下什么是消息中间件，只是粗略的讲解，目前kafka已经可以做更多的事情。

举个例子，生产者消费者，生产者生产鸡蛋，消费者消费鸡蛋，生产者生产一个鸡蛋，消费者就消费一个鸡蛋，假设消费者消费鸡蛋的时候噎住了（系统宕机了），生产者还在生产鸡蛋，那新生产的鸡蛋就丢失了。再比如生产者很强劲（大交易量的情况），生产者1秒钟生产100个鸡蛋，消费者1秒钟只能吃50个鸡蛋，那要不了一会，消费者就吃不消了（消息堵塞，最终导致系统超时），消费者拒绝再吃了，”鸡蛋“又丢失了，这个时候我们放个篮子在它们中间，生产出来的鸡蛋都放到篮子里，消费者去篮子里拿鸡蛋，这样鸡蛋就不会丢失了，都在篮子里，而这个篮子就是”kafka“。
鸡蛋其实就是“数据流”，系统之间的交互都是通过“数据流”来传输的（就是tcp、https什么的），也称为报文，也叫“消息”。
消息队列满了，其实就是篮子满了，”鸡蛋“ 放不下了，那赶紧多放几个篮子，其实就是kafka的扩容。
各位现在知道kafka是干什么的了吧，它就是那个"篮子"。


# kafka名词解释
后面大家会看到一些关于kafka的名词，比如topic、producer、consumer、broker，我这边来简单说明一下。

producer：生产者，就是它来生产“鸡蛋”的。
consumer：消费者，生出的“鸡蛋”它来消费。
topic：你把它理解为标签，生产者每生产出来一个鸡蛋就贴上一个标签（topic），消费者可不是谁生产的“鸡蛋”都吃的，这样不同的生产者生产出来的“鸡蛋”，消费者就可以选择性的“吃”了。
broker：就是篮子了。
大家一定要学会抽象的去思考，上面只是属于业务的角度，如果从技术角度，topic标签实际就是队列，生产者把所有“鸡蛋（消息）”都放到对应的队列里了，消费者到指定的队列里取。


