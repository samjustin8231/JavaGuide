# MySQL中索引的语法
todo


注：

创建索引时需要`对表加锁`，因此实际操作中需要在业务空闲期间进行
## 查看查询语句使用索引的情况
```
//explain 加查询语句
explain SELECT * FROM table_name WHERE column_1='123';
```


# 索引分类
1. 普通索引
	
	仅加速查询 最基本的索引，没有任何限制，是我们大多数情况下使用到的索引。
```
CREATE INDEX  index_name  on user_info(name)  ;
```

2. 唯一索引

	与普通索引类型，不同的是：加速查询 + 列值唯一（可以有null）
	```
	CREATE UNIQUE INDEX  mail  on user_info(name)  ;
	```
3. 全文索引（FULLTEXT）
4. 组合索引（最左前缀）

	将几个列作为一条索引进行检索，使用最左匹配原则。



# 索引实现原理

## 索引原理
### 一 原理介绍
索引的目的在于提高查询效率，与我们查阅图书所用的目录是一个道理：先定位到章，然后定位到该章下的一个小节，然后找到页数。相似的例子还有：查字典，查火车车次，飞机航班等

本质都是：`通过不断地缩小`想要获取数据的范围来筛选出最终想要的结果，同时把随机的事件变成顺序的事件，也就是说，有了这种索引机制，我们可以总是用同一种查找方式来锁定数据。

数据库也是一样，但显然要复杂的多，因为不仅面临着等值查询，还有范围查询(>、<、between、in)、模糊查询(like)、并集查询(or)等等。数据库应该选择怎么样的方式来应对所有的问题呢？我们回想字典的例子，能不能把数据分成段，然后分段查询呢？最简单的如果1000条数据，1到100分成第一段，101到200分成第二段，201到300分成第三段......这样查第250条数据，只要找第三段就可以了，一下子去除了90%的无效数据。但如果是1千万的记录呢，分成几段比较好？稍有算法基础的同学会想到搜索树，其平均复杂度是lgN，具有不错的查询性能。但这里我们忽略了一个关键的问题，复杂度模型是基于每次相同的操作成本来考虑的。而数据库实现比较复杂，一方面数据是保存在磁盘上的，另外一方面为了提高性能，每次又可以把部分数据读入内存来计算，因为我们知道访问磁盘的成本大概是访问内存的十万倍左右，所以简单的搜索树难以满足复杂的应用场景。

### 二 磁盘IO与预读

考虑到磁盘IO是非常高昂的操作，计算机操作系统做了一些优化，当一次IO时，不光把当前磁盘地址的数据，而是把相邻的数据也都读取到内存缓冲区内，因为局部预读性原理告诉我们，当计算机访问一个地址的数据的时候，与其相邻的数据也会很快被访问到。每一次IO读取的数据我们称之为一页(page)。具体一页有多大数据跟操作系统有关，一般为4k或8k，也就是我们读取一页内的数据时候，实际上才发生了一次IO，这个理论对于索引的数据结构设计非常有帮助。

### 三 索引的数据结构

任何一种数据结构都不是凭空产生的，一定会有它的背景和使用场景，我们现在总结一下，我们需要这种数据结构能够做些什么，其实很简单，那就是：每次查找数据时把磁盘IO次数控制在一个很小的数量级，最好是常数数量级。那么我们就想到如果一个高度可控的多路搜索树是否能满足需求呢？就这样，b+树应运而生。

![](索引b+树.png)
如上图，是一颗b+树，关于b+树的定义可以参见B+树，这里只说一些重点，浅蓝色的块我们称之为一个磁盘块，可以看到每个磁盘块包含几个数据项（深蓝色所示）和指针（黄色所示），如磁盘块1包含数据项17和35，包含指针P1、P2、P3，P1表示小于17的磁盘块，P2表示在17和35之间的磁盘块，P3表示大于35的磁盘块。真实的数据存在于叶子节点即3、5、9、10、13、15、28、29、36、60、75、79、90、99。非叶子节点只不存储真实的数据，只存储指引搜索方向的数据项，如17、35并不真实存在于数据表中。

> b+树的查找过程

如图所示，如果要查找数据项29，那么首先会把磁盘块1由磁盘加载到内存，此时发生一次IO，在内存中用二分查找确定29在17和35之间，锁定磁盘块1的P2指针，内存时间因为非常短（相比磁盘的IO）可以忽略不计，通过磁盘块1的P2指针的磁盘地址把磁盘块3由磁盘加载到内存，发生第二次IO，29在26和30之间，锁定磁盘块3的P2指针，通过指针加载磁盘块8到内存，发生第三次IO，同时内存中做二分查找找到29，结束查询，总计三次IO。真实的情况是，3层的b+树可以表示上百万的数据，如果上百万的数据查找只需要三次IO，性能提高将是巨大的，如果没有索引，每个数据项都要发生一次IO，那么总共需要百万次的IO，显然成本非常非常高。

> b+树性质

1. `索引字段要尽量的小`：通过上面的分析，我们知道IO次数取决于b+数的高度h，假设当前数据表的数据为N，每个磁盘块的数据项的数量是m，则有h=㏒(m+1)N，当数据量N一定的情况下，m越大，h越小；而m = 磁盘块的大小 / 数据项的大小，磁盘块的大小也就是一个数据页的大小，是固定的，如果数据项占的空间越小，数据项的数量越多，树的高度越低。这就是为什么每个数据项，即索引字段要尽量的小，比如int占4字节，要比bigint8字节少一半。这也是为什么b+树要求把真实的数据放到叶子节点而不是内层节点，一旦放到内层节点，磁盘块的数据项会大幅度下降，导致树增高。当数据项等于1时将会退化成线性表。

2. 索引的`最左匹配特性`（即从左往右匹配）：当b+树的数据项是复合的数据结构，比如(name,age,sex)的时候，b+数是按照从左到右的顺序来建立搜索树的，比如当(张三,20,F)这样的数据来检索的时候，b+树会优先比较name来确定下一步的所搜方向，如果name相同再依次比较age和sex，最后得到检索的数据；但当(20,F)这样的没有name的数据来的时候，b+树就不知道下一步该查哪个节点，因为建立搜索树的时候name就是第一个比较因子，必须要先根据name来搜索才能知道下一步去哪里查询。比如当(张三,F)这样的数据来检索时，b+树可以用name来指定搜索方向，但下一个字段age的缺失，所以只能把名字等于张三的数据都找到，然后再匹配性别是F的数据了， 这个是非常重要的性质，即索引的最左匹配特性。

## 哈希索引：
只有`memory`（内存）存储引擎支持哈希索引，哈希索引用索引列的值计算该值的hashCode，然后在hashCode相应的位置存执该值所在行数据的物理位置，因为使用散列算法，因此`访问速度非常快`，但是一个值只能对应一个hashCode，而且是散列的分布方式，因此哈希索引不`支持范围查找和排序的功能`。



## 全文索引：
`FULLTEXT`（全文）索引，仅可用于`MyISAM和InnoDB`，针对较大的数据，生成全文索引非常的消耗时间和空间。对于文本的大对象，或者较大的CHAR类型的数据，如果使用普通索引，那么匹配文本前几个字符还是可行的，但是想要匹配文本中间的几个单词，那么就要使用LIKE %word%来匹配，这样需要很长的时间来处理，响应时间会大大增加，这种情况，就可使用时FULLTEXT索引了，在生成FULLTEXT索引时，会为文本生成`一份单词的清单`，在索引时及根据这个单词的清单来索引。


## BTree索引和B+Tree

## 聚簇索引和非聚簇索引

# 索引注意点
## 什么场景不适合创建索引
第一，对于`那些在查询中很少使用`或者参考的列不应该创建索引。这是因 为，既然这些列很少使用到，因此有索引或者无索引，并不能提高查询速度。相反，由于增加了索引，反而降低了系统的维护速度和增大了空间需求。

第二，对于那 些`只有很少数据值的列`也不应该增加索引。因为本来结果集合就是相当于全表查询了，所以没有必要。这是因为，由于这些列的取值很少，例如人事表的性别列，在查询的结果中，结果集的数据行占了表中数据行的很大比 例，即需要在表中搜索的数据行的比例很大。增加索引，并不能明显加快检索速度。

第三，对于那些定义为`text, image和bit`数据类型的列不应该增加索引。这是因为，这些列的数据量要么相当大，要么取值很少。

第四，当修改性能远远大于检索性能时，不应该创建索 引。这是因为，修改性能和检索性能是互相矛盾的。当增加索引时，会提高检索性能，但是会降低修改性能。当减少索引时，会提高修改性能，降低检索性能。因 此，当修改性能远远大于检索性能时，不应该创建索引。

第五，`不会出现在where条件中`的字段不该建立索引。

## 什么样的字段适合创建索引
1. 表的`主键、外键必须有索引`；外键是唯一的，而且经常会用来查询 
2. 数据量超过300的表应该有索引；
3. 经常与其他表进行连接的表，在`连接字段上应该建立索引`；经常连接查询，需要有索引 
4. 经常出现在`Where子句中的字段`，加快判断速度，特别是大表的字段，应该建立索引，建立索引，一般用在select ……where f1 and f2 ，我们在f1或者f2上建立索引是没用的。只有两个使用联合索引才能有用
5. `经常用到排序`的列上，因为`索引已经排序`。
6. 经常`用在范围内搜索的列上`创建索引，因为索引已经排序了，其指定的范围是连续的

## 索引失效的情况

- like '%xx'
    
    ```
    select * from tb1 where email like '%cn';
    ```
    
    
- 使用函数
    select * from tb1 where reverse(email) = 'wupeiqi';
    
    
- or
    
    ```
    select * from tb1 where nid = 1 or name = 'seven@live.com';
    ```
    
    特别的：当or条件中有未建立索引的列才失效，以下会走索引
    
    ```
    select * from tb1 where nid = 1 or name = 'seven';
    select * from tb1 where nid = 1 or name = 'seven@live.com' and email = 'alex'
    ```
    
- 类型不一致
    如果列是字符串类型，传入条件是必须用引号引起来，不然...
    
    ```
    select * from tb1 where email = 999;
    ```
    

- 普通索引的不等于不会走索引 !=
    
    ```
    select * from tb1 where email != 'alex'
    
    特别的：如果是主键，则还是会走索引
    select * from tb1 where nid != 123
    ```


- order by 排序条件为索引，则select字段必须也是索引字段，否则无法命中
    
    ```
    select name from s1 order by email desc;
    当根据索引排序时候，select查询的字段如果不是索引，则不走索引
    select email from s1 order by email desc;
    特别的：如果对主键排序，则还是走索引：
    select * from tb1 order by nid desc;
    ```
    
- 组合索引最左前缀
    
    ```
    如果组合索引为：(name,email)
    name and email       -- 使用索引
    name                 -- 使用索引
    email                -- 不使用索引
    ```


- count(1)或count(列)代替count(*)在mysql中没有差别了

## 索引规则

1. 最左前缀匹配原则，非常重要的原则，
create index ix_name_email on s1(name,email,)

	最左前缀匹配：必须按照从左到右的顺序匹配
		
	```
	select * from s1 where name='egon'; #可以
	select * from s1 where name='egon' and email='asdf'; #可以
	select * from s1 where email='alex@oldboy.com'; #不可以
	mysql会一直向右匹配直到遇到范围查询(>、<、between、like)就停止匹配，
	比如a = 1 and b = 2 and c > 3 and d = 4 如果建立(a,b,c,d)顺序的索引，
	d是用不到索引的，如果建立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整。
	```

2. =和in可以乱序，比如a = 1 and b = 2 and c = 3 建立(a,b,c)索引可以任意顺序，mysql的查询优化器
会帮你优化成索引可以识别的形式

3. 尽量选择区分度高的列作为索引,区分度的公式是count(distinct col)/count(*)，
表示字段不重复的比例，比例越大我们扫描的记录数越少，唯一键的区分度是1，而一些状态、
性别字段可能在大数据面前区分度就是0，那可能有人会问，这个比例有什么经验值吗？使用场景不同，
这个值也很难确定，一般需要join的字段我们都要求是0.1以上，即平均1条扫描10条记录

4. 索引列不能参与计算，保持列“干净”，比如from_unixtime(create_time) = ’2014-05-29’
就不能使用到索引，原因很简单，b+树中存的都是数据表中的字段值，
但进行检索时，需要把所有元素都应用函数才能比较，显然成本太大。
所以语句应该写成create_time = unix_timestamp(’2014-05-29’);


## 注意点
- 避免使用select *
- count(1)或count(列) 代替 count(*)
- 创建表时尽量时 char 代替 varchar
- 表的字段顺序固定长度的字段优先
- 组合索引代替多个单列索引（经常使用多个条件查询时）
- 尽量使用短索引
- 使用连接（JOIN）来代替子查询(Sub-Queries)
- 连表时注意条件类型需一致
- 索引散列值（重复少）不适合建索引，例：性别不适合

# 索引优缺点
## 2.1、优点
索引由数据库中一列或多列组合而成，其作用是提高对表中数据的查询速度
索引的优点是可以提高检索数据的速度

## 2.2、缺点
索引的缺点是创建和维护索引需要耗费时间<br/>
索引可以提高查询速度，会减慢写入速度

索引并不是越多越好，索引固然可以提高相应的 select 的效率，但同时也降低了 insert 及 update 的效率，因为 insert 或 update 时有可能会重建索引，所以怎样建索引需要慎重考虑，视具体情况而定。一个表的索引数最好不要超过6个，若太多则应考虑一些不常使用到的列上建的索引是否有必要。

# 慢查询优化
0. 先运行看看是否真的很慢，注意设置SQL_NO_CACHE
1. where条件单表查，锁定最小返回记录表。这句话的意思是把查询语句的where都应用到表中返回的记录数最小的表开始查起，单表每个字段分别查询，看哪个字段的区分度最高
2. explain查看执行计划，是否与1预期一致（从锁定记录较少的表开始查询）
3. order by limit 形式的sql语句让排序的表优先查
4. 了解业务方使用场景
5. 加索引时参照建索引的几大原则
6. 观察结果，不符合预期继续从0分析

# 参考文献
- [深入理解MySQL索引原理和实现——为什么索引可以加速查询？](https://blog.csdn.net/tongdanping/article/details/79878302)
- [MySQL索引原理以及查询优化](https://www.cnblogs.com/bypp/p/7755307.html)
- [【从入门到入土】令人脱发的数据库底层设计](https://juejin.im/post/5d6f3efde51d4561fd6cb548)