# 锁机制

## 读锁和写锁

首先读锁还有一个名称叫共享锁，写锁也相应的还有个名称叫排它锁，也就是说共享锁和读锁是同一个东西，排它锁和写锁是同一个东西。读锁、写锁是系统实现层面上的锁，也是最基础的锁。读锁和写锁还是锁的一种性质，比如行锁里，有行写锁和行读锁。MDL 锁里也有 MDL 写锁和 MDL 读锁。读锁和写锁的加锁关系如下，Y 表示可以共存，X 表示互斥。

|  | 读锁 | 写锁 |
| --- | --- | --- |
| 读锁 | Y | X |
| 写锁 | X | X |

之前的文章已经介绍了 MySQL 的存储模型，对于 InnoDB 引擎而言，采用的是 B+ 树索引，假设需要将整个表锁住那么`需要在整个 B+ 树的每个节点上都加上锁`，显然这是个非常低效的做法。因此，MySQL 提出了`意向锁的概念`，意向锁就是如果要在一个节点上加锁就必须在其所有的祖先节点加上意向锁。关于意向锁还有更多复杂设计，如果想了解可以查看 《数据库系统概率》 一书。


## 表锁和行锁

表锁和行锁是两种不同加锁粒度的锁。除了表锁和行锁以外还有更大粒度的锁——全局锁。

全局锁： 全局锁会锁住整个数据库，MySQL 使用 flush tables with read lock 命令来加全局锁，使用 unlock tables 解锁。线程退出后锁也会自动释放。当加上全局锁以后，除了当前线程以外，其他线程的更新操作都会被阻塞，包括增删改数据表中的数据、建表、修改表结构等。全局锁的典型使用场景是全库的逻辑备份。

表锁： 表锁会锁住一张表，MySQL 使用 lock tables  read/write 命令给表加上读锁或写锁，通过 unlock tables 命令释放表锁。通过 lock tables t read 给表 t 加上读锁后，当前线程只能访问表 t，不能访问数据库中的其他表，对表 t 也只有读权限，不能进行修改操作。通过 lock tables t write 给表 t 加上写锁后，当前线程只能访问表 t，不能访问数据库中的其他表，对表 t 有读写权限。

行锁： 行锁会锁锁住表中的某一行或者多行，MySQL 使用 lock in share mode 命令给行加读锁，用 for update 命令给行加写锁，行锁不需要显示释放，当事务被提交时，该事务中加的行锁就会被释放。通过 select k from t where k = 1 for update 命令可以锁住 k 为 1 的所有行。另外当使用 update 命令更新表数据时，会自动给命中的行加上行锁。另外 MySQL 加行锁时并不是一次性把所有的行都加上锁，执行一个 update 命令之后，server 层将命令发送给 InnoDB 引擎，InnoDB 引擎找到第一条满足条件的数据，并加锁后返回给 server 层，server 层更新这条数据然后传给 InnoDB 引擎。完成这条数据的更新后，server 层再取下一条数据。


# 参考文献

* [MySQL 的锁](https://juejin.im/post/5d7f8cede51d4561fd6cb58f)

