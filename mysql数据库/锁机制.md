# 锁机制

## 读锁和写锁

首先读锁还有一个名称叫共享锁，写锁也相应的还有个名称叫排它锁，也就是说共享锁和读锁是同一个东西，排它锁和写锁是同一个东西。读锁、写锁是系统实现层面上的锁，也是最基础的锁。读锁和写锁还是锁的一种性质，比如行锁里，有行写锁和行读锁。MDL 锁里也有 MDL 写锁和 MDL 读锁。读锁和写锁的加锁关系如下，Y 表示可以共存，X 表示互斥。

|  | 读锁 | 写锁 |
| --- | --- | --- |
| 读锁 | Y | X |
| 写锁 | X | X |

之前的文章已经介绍了 MySQL 的存储模型，对于 InnoDB 引擎而言，采用的是 B+ 树索引，假设需要将整个表锁住那么`需要在整个 B+ 树的每个节点上都加上锁`，显然这是个非常低效的做法。因此，MySQL 提出了`意向锁的概念`，意向锁就是如果要在一个节点上加锁就必须在其所有的祖先节点加上意向锁。关于意向锁还有更多复杂设计，如果想了解可以查看 《数据库系统概率》 一书。


总结：按照对数据操作的类型分：读锁，写锁

- 读锁：也称为共享锁。 针对同一资源，多个并发读操作可以并行执行，并且互不影响，但是不能写
- 写锁：也称排它锁。当前线程写数据的时候，会阻塞其它线程来读取数据 或者 写数据
注：读锁和写锁都是阻塞锁。

## 表锁和行锁

表锁和行锁是两种不同加锁粒度的锁。除了表锁和行锁以外还有更大粒度的锁——全局锁。

全局锁： 全局锁会锁住整个数据库，MySQL 使用 flush tables with read lock 命令来加全局锁，使用 unlock tables 解锁。线程退出后锁也会自动释放。当加上全局锁以后，除了当前线程以外，其他线程的更新操作都会被阻塞，包括增删改数据表中的数据、建表、修改表结构等。全局锁的典型使用场景是全库的逻辑备份。

表锁： 表锁会锁住一张表，MySQL 使用 lock tables  read/write 命令给表加上读锁或写锁，通过 unlock tables 命令释放表锁。通过 lock tables t read 给表 t 加上读锁后，当前线程只能访问表 t，不能访问数据库中的其他表，对表 t 也只有读权限，不能进行修改操作。通过 lock tables t write 给表 t 加上写锁后，当前线程只能访问表 t，不能访问数据库中的其他表，对表 t 有读写权限。

行锁： 行锁会锁锁住表中的某一行或者多行，MySQL 使用 lock in share mode 命令给行加读锁，用 for update 命令给行加写锁，行锁不需要显示释放，当事务被提交时，该事务中加的行锁就会被释放。通过 select k from t where k = 1 for update 命令可以锁住 k 为 1 的所有行。`另外当使用 update 命令更新表数据时，会自动给命中的行加上行锁`。另外 MySQL 加行锁时并不是一次性把所有的行都加上锁，执行一个 update 命令之后，server 层将命令发送给 InnoDB 引擎，InnoDB 引擎找到第一条满足条件的数据，并加锁后返回给 server 层，server 层更新这条数据然后传给 InnoDB 引擎。完成这条数据的更新后，server 层再取下一条数据。


总结：按照数据操作的粒度：表锁，行锁，页锁

- 表锁：开销小，加锁快，主要在myisam存储引擎中出现。特点：锁住整个表，开销小，加锁快，无死锁情况， 锁的粒度大，在并发情况下，产生锁等待的概率比较高，所以说，支持的并发数比较低，一般用于查找
- 行锁：开销大，加锁慢，锁定单独的某个表中的某一行记录，主要用于innodb存储引擎。特点：有死锁情况，锁定粒度最小，发生锁冲突的概率最低，支持的并发数也最高
- 页锁：开销和加锁时间界于表锁和行锁之间。会出现死锁，锁定粒度界于表锁和行锁之间，并发度一般

# 参考文献

* [MySQL 的锁](https://juejin.im/post/5d7f8cede51d4561fd6cb58f)

