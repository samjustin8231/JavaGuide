# 表锁
数据库的锁主要用来保证数据的一致性的。MyISAM存储引擎只支持表锁，InnoDB存储引擎既支持行锁，也支持表锁，但默认情况下是采用行锁。


# 行锁

## 行锁概念及特点
1.概念：给单独的一行记录加锁，主要应用于innodb表存储引擎

2.特点：在innodb存储引擎中应用比较多，支持事务、开销大、加锁慢；会出现死锁；锁的粒度小，并发情况下，产生锁等待的概率比较低，所以支持的并发数比较高。

## 数据库事务
1.概念：事务是一系列操作组成的工作单元，该工作单元内的操作是不可分割的，也就是说要么全部都执行，要么全部不执行。
2.特性：ACID

- 原子性：事务是最小的工作单元，不可分割，要么都做，要么都不做
- 一致性：事务执行前和执行后的数据要保证正确性，数据完整性没有被破坏。
- 隔离性：在并发事务执行的时候，一个事务对其他事务不会产生影响。
- 持久性：一个事务一旦提交，它对数据库中的数据的改变就应该是永久性的

## 多个事务并发执行 问题及解决方案

1.问题

- 丢失更新：在没有事务隔离的情况下，两个事务同时更新一条数据，后一个事务 会 覆盖前面事务的更新，导致前面的事务丢失更新。
- 脏读：事务A先更新数据，但是没有提交，事务B读到了事务A没有提交的数据。
- 不可重复读：事务A中，先读到一条数据，事务A还没有结束，此时，事务B对该条数据进行了修改操作，事务A又读到了这条数据，事务A两次读到的数据不同。
- 幻读：事务A先读到一批数据，假设读到10条，事务B插入了一条数据，此时，事务A又读这一批数据，发现多了一条，好像幻觉一样。

注：
- 不可重复读的重点是修改，同样的条件，你读取过的数据，再次读取出来发现值不一样。
- 幻读的重点在于新增或者删除，同样的条件，第 1 次和第 2 次读出来的记录数不一样。

2.解决方案--数据库隔离机制


- 未提交读（read uncommitted）：这是数据库最低的隔离级别，允许一个事务读另一个事务未提交的数据。
解决了丢失更新，但是会出现脏读、不可重复读、幻读。


- 提交读（read committed）：一个事务更新的数据 在提交之后 才可以被另一个事务读取，即一个事务不可以读取到另一个事务未提交的数据。
解决了丢失更新和脏读，但是会出现不可重复读和幻读。


- 可重复读（repeatale read）：这是数据库默认的事务隔离级别，保证一个事务在相同条件下前后两次读取的数据是一致的。
解决了丢失更新、脏读和不可重复读，但是会出现幻读。


- 序列化（serializable）：这是数据库最高的隔离级别。事务串行执行，不会交叉执行。
解决了所有的问题。


注：乐观所可以解决幻读。



# 参考

- [MySQL -- 表锁(通俗易懂)](https://juejin.im/post/5b567c0f6fb9a04fc0310d44)
- [MySQL -- 行锁](https://juejin.im/post/5b567dcde51d4519133fb288)